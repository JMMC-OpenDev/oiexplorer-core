/*******************************************************************************
 * JMMC project ( http://www.jmmc.fr ) - Copyright (C) CNRS.
 ******************************************************************************/
package fr.jmmc.oiexplorer.core.gui;

import fr.jmmc.jmcs.gui.component.GenericListModel;
import fr.jmmc.oiexplorer.core.model.OIBase;
import fr.jmmc.oiexplorer.core.model.OIFitsCollectionEventListener;
import fr.jmmc.oiexplorer.core.model.OIFitsCollectionManager;
import fr.jmmc.oiexplorer.core.model.PlotDefinitionFactory;
import fr.jmmc.oiexplorer.core.model.event.GenericEvent;
import fr.jmmc.oiexplorer.core.model.event.OIFitsCollectionEventType;
import fr.jmmc.oiexplorer.core.model.oi.Identifiable;
import fr.jmmc.oiexplorer.core.model.oi.Plot;
import fr.jmmc.oiexplorer.core.model.oi.SubsetDefinition;
import fr.jmmc.oiexplorer.core.model.plot.PlotDefinition;
import java.awt.Component;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import javax.swing.DefaultListCellRenderer;
import javax.swing.JList;
import javax.swing.ListModel;
import javax.swing.ListSelectionModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author mella
 */
public final class PlotEditor extends javax.swing.JPanel implements OIFitsCollectionEventListener {

    /** default serial UID for Serializable interface */
    private static final long serialVersionUID = 1;
    /** Class logger */
    private static final Logger logger = LoggerFactory.getLogger(PlotEditor.class.getName());

    /* members */
    /** OIFitsCollectionManager singleton reference */
    private final OIFitsCollectionManager ocm = OIFitsCollectionManager.getInstance();
    /** Associated plot identifier */
    private String plotId = null;
    /** Associated plot instance */
    private Plot plot = null;

    /** Creates new form PlotEditor */
    public PlotEditor() {
        ocm.getOiFitsCollectionEventNotifier().register(this);
        ocm.getPlotEventNotifier().register(this);

        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        subsetComboBox = new javax.swing.JComboBox();
        plotDefinitionComboBox = new javax.swing.JComboBox();
        subsetLabel = new javax.swing.JLabel();
        plotDefinitionLabel = new javax.swing.JLabel();

        setLayout(new java.awt.GridBagLayout());

        subsetComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subsetComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        add(subsetComboBox, gridBagConstraints);

        plotDefinitionComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                plotDefinitionComboBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        add(plotDefinitionComboBox, gridBagConstraints);

        subsetLabel.setText("subset:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        add(subsetLabel, gridBagConstraints);

        plotDefinitionLabel.setText("plot config:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        add(plotDefinitionLabel, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private void subsetComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subsetComboBoxActionPerformed
        final String subsetId = (String) subsetComboBox.getSelectedItem();

        if (subsetId == null) {
            logger.warn("[{}] subsetComboBoxActionPerformed() event ignored : no current selection", plotId);
            return;
        }

        final Plot plotCopy = getPlot();
        if (plotCopy != null) {
            plotCopy.setSubsetDefinition(ocm.getSubsetDefinitionRef(subsetId));
            ocm.updatePlot(plotCopy);
        }
    }//GEN-LAST:event_subsetComboBoxActionPerformed

    private void plotDefinitionComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_plotDefinitionComboBoxActionPerformed
        final String plotDefId = (String) plotDefinitionComboBox.getSelectedItem();

        if (plotDefId == null) {
            logger.warn("[{}] plotDefinitionComboBoxActionPerformed() event ignored : no current selection", plotId);
            return;
        }

        // get copy:
        final Plot plotCopy = getPlot();

        if (plotCopy != null) {

            if (ocm.hasPlotDefinition(plotDefId)) {
                // collection has it: use it
                plotCopy.setPlotDefinition(ocm.getPlotDefinitionRef(plotDefId));
            } else {
                // clone preset (same id):
                final PlotDefinition plotDefCopy = (PlotDefinition) PlotDefinitionFactory.getInstance().getDefault(plotDefId).clone();

                ocm.addPlotDefinition(plotDefCopy);

                plotCopy.setPlotDefinition(plotDefCopy);
            }

            ocm.updatePlot(plotCopy);
        }
    }//GEN-LAST:event_plotDefinitionComboBoxActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox plotDefinitionComboBox;
    private javax.swing.JLabel plotDefinitionLabel;
    private javax.swing.JComboBox subsetComboBox;
    private javax.swing.JLabel subsetLabel;
    // End of variables declaration//GEN-END:variables

    /**
     * Define the plot identifier, reset plot and fireOIFitsCollectionChanged on this instance if the plotId changed
     * @param plotId plot identifier
     */
    public void setPlotId(final String plotId) {
        final String prevPlotId = this.plotId;
        this.plotId = plotId;
        // force reset:
        this.plot = null;

        if (!OIBase.areEquals(prevPlotId, plotId)) {
            logger.warn("setPlotId {}", plotId);
            // fire PlotChanged event to initialize correctly the widget:
            ocm.firePlotChanged(plotId, this);
        }
    }

    private Plot getPlot() {
        if (this.plot == null) {
            this.plot = ocm.getPlot(plotId);
        }
        return this.plot;
    }

    private void refreshForm() {
        logger.warn("refreshForm: {}", plotId);

        // Put all subset references:
        final List<String> subsetNames = new ArrayList<String>();
        for (SubsetDefinition subset : ocm.getUserCollection().getSubsetDefinitions()) {
            subsetNames.add(subset.getName());
        }

        subsetComboBox.setModel(new GenericListModel<String>(subsetNames, true));

        // use identifiers to keep unique values:
        final Set<String> plotDefNames = new LinkedHashSet<String>();
        for (PlotDefinition plotDef : ocm.getUserCollection().getPlotDefinitions()) {
            plotDefNames.add(plotDef.getName());
        }
        for (PlotDefinition plotDef : PlotDefinitionFactory.getInstance().getDefaults()) {
            plotDefNames.add(plotDef.getName());
        }

        final GenericListModel<String> plotDefModel = new GenericListModel<String>(new ArrayList<String>(plotDefNames), true);
        plotDefinitionComboBox.setModel(plotDefModel);

        // hide subset combo if only 1
        final boolean showSubsets = (subsetComboBox.getModel().getSize() > 1);
        subsetLabel.setVisible(showSubsets);
        subsetComboBox.setVisible(showSubsets);

        // restore current state:
        final Plot plotCopy = getPlot();

        if (plotCopy != null) {
            subsetComboBox.setSelectedItem((plotCopy.getSubsetDefinition() != null) ? plotCopy.getSubsetDefinition().getName() : null);
            plotDefinitionComboBox.setSelectedItem((plotCopy.getPlotDefinition() != null) ? plotCopy.getPlotDefinition().getName() : null);
        }
    }

    /* --- OIFitsCollectionEventListener implementation --- */
    /**
     * Return the optional subject id i.e. related object id that this listener accepts
     * @see GenericEvent#subjectId
     * @param type event type
     * @return subject id i.e. related object id (null allowed)
     */
    public String getSubjectId(final OIFitsCollectionEventType type) {
        // always return null as refreshForm must be performed for any plot changed event:
        return null;
    }

    /**
     * Handle the given OIFits collection event
     * @param event OIFits collection event
     */
    @Override
    public void onProcess(GenericEvent<OIFitsCollectionEventType> event) {
        logger.warn("[{}] onProcess : {}", plotId, event);

        switch (event.getType()) {
            case CHANGED:
            case PLOT_CHANGED:
                // force clean up ...
                setPlotId(plotId);

                refreshForm();
                break;
            default:
        }
    }

    /**
     * This custom renderer uses the identifier only (NOT USED)
     * @author bourgesl
     */
    private static final class IdentifiableListRenderer extends DefaultListCellRenderer {

        /** default serial UID for Serializable interface */
        private static final long serialVersionUID = 1;

        /**
         * Public constructor
         */
        private IdentifiableListRenderer() {
            super();
        }

        /**
         * Return a component that has been configured to display the specified
         * value. That component's <code>paint</code> method is then called to
         * "render" the cell.  If it is necessary to compute the dimensions
         * of a list because the list cells do not have a fixed size, this method
         * is called to generate a component on which <code>getPreferredSize</code>
         * can be invoked.
         *
         * @param list The JList we're painting.
         * @param value The value returned by list.getModel().getElementAt(index).
         * @param index The cells index.
         * @param isSelected True if the specified cell was selected.
         * @param cellHasFocus True if the specified cell has the focus.
         * @return A component whose paint() method will render the specified value.
         *
         * @see JList
         * @see ListSelectionModel
         * @see ListModel
         */
        @Override
        public Component getListCellRendererComponent(
                final JList list,
                final Object value,
                final int index,
                final boolean isSelected,
                final boolean cellHasFocus) {

            final String val;
            if (value == null) {
                val = null;
            } else if (value instanceof Identifiable) {
                val = ((Identifiable) value).getName();
            } else {
                val = value.toString();
            }

            super.getListCellRendererComponent(
                    list, val, index,
                    isSelected, cellHasFocus);

            return this;
        }
    }
}
